# 비트 연산

## 비트 연산자
- &(AND) : 둘 다 1이면 1을 반환
- /(OR) : 둘 중 하나가 1이면 1을 반환
- ^(XOR) : 둘이 다르면 1을 반환
- ~(NOT) : 1이면 0을, 0이면 1을 반환
- <<(LEFT SHIFT) : 비트를 왼쪽으로 옮김(x2와 동일)
- >>(RIGHT SHIFT) : 비트를 오른쪽으로 옮김(/2와 동일)

__비트 연산자는 우선순위가 다르다. 논리 연산보단 우선순위가 높으나, 비교 연산보단 낮다.__

## 비트 연산 응용
- 비트 집합 두개를 AND하면 교집합, OR하면 합집합을 구할 수 있다.
- ^(XOR)을 활용해 true, false를 번갈아 바꾸는 스위치를 만들 수 있다. -> 잘만 응용하면 많은 곳에 사용 가능
- ~(NOT)을 비트 집합에 사용하면 가지고 있지 않은 원소를 구할 수 있다.
- ~(NOT)을 음의 인덱스로 사용할 수 있다. `vector.end()[~i]`의 형태로 뒤에서부터 index를 셀 수 있다.
- >>, << 로 x2나 /2를 좀 더 빠르게 할 수 있다.

## 비트 마스킹
> 각 비트를 하나의 flag로 활용한다면, 자료의 저장과 집합 표현을 좀 더 빠르고 쉽게 할 수 있다.      

내가 가지고 있는 index의 비트를 1로 바꾸는 형식으로 어떤 집합을 나타낸다면, 교집합, 합집합 등의 연산을 빠르게 할 수 있다.

## 데이터 압축
> 문자열 2개를 비교하는 데에는 원래 O(N)의 시간이 걸린다.      
> 하지만, 문자를 비트로 바꿔서 하나의 정수에 저장한다면?     
> 2개의 정수를 ^(XOR)하는 시간인 O(1)만으로 비교를 끝낼 수 있다.
